#pragma version 8
intcblock 1 0 8
bytecblock 0x00000000000003e8
txn NumAppArgs
intc_1 // 0
==
bnz main_l6
txna ApplicationArgs 0
pushbytes 0x9579aa48 // "unit_test(uint64,uint64)uint64"
==
bnz main_l5
txna ApplicationArgs 0
pushbytes 0x4c6bea72 // "opup()void"
==
bnz main_l4
err
main_l4:
txn OnCompletion
intc_1 // NoOp
==
txn ApplicationID
intc_1 // 0
!=
&&
assert
callsub opup_11
intc_0 // 1
return
main_l5:
txn OnCompletion
intc_1 // NoOp
==
txn ApplicationID
intc_1 // 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 0
txna ApplicationArgs 2
btoi
store 1
load 0
load 1
callsub unittest_10
store 2
pushbytes 0x151f7c75 // 0x151f7c75
load 2
itob
concat
log
intc_0 // 1
return
main_l6:
txn OnCompletion
intc_1 // NoOp
==
bnz main_l16
txn OnCompletion
intc_0 // OptIn
==
bnz main_l15
txn OnCompletion
pushint 2 // CloseOut
==
bnz main_l14
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz main_l13
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz main_l12
err
main_l12:
txn ApplicationID
intc_1 // 0
!=
assert
callsub delete_6
intc_0 // 1
return
main_l13:
txn ApplicationID
intc_1 // 0
!=
assert
callsub update_7
intc_0 // 1
return
main_l14:
txn ApplicationID
intc_1 // 0
!=
assert
callsub closeout_9
intc_0 // 1
return
main_l15:
txn ApplicationID
intc_1 // 0
!=
assert
callsub optin_8
intc_0 // 1
return
main_l16:
txn ApplicationID
intc_1 // 0
==
assert
callsub create_5
intc_0 // 1
return

// wide_factorial
widefactorial_0:
store 4
load 4
bitlen
intc_0 // 1
==
bnz widefactorial_0_l2
load 4
load 4
intc_0 // 1
itob
b-
load 4
swap
callsub widefactorial_0
swap
store 4
b*
b widefactorial_0_l3
widefactorial_0_l2:
load 4
widefactorial_0_l3:
retsub

// wide_power
widepower_1:
expw
callsub stacktowide_4
retsub

// exponential_impl
exponentialimpl_2:
store 8
store 7
store 6
store 5
load 7
intc_0 // 1
==
bnz exponentialimpl_2_l2
load 5
load 6
load 7
itob
b/
load 7
intc_0 // 1
-
load 8
load 5
load 6
load 7
load 8
uncover 7
uncover 7
uncover 7
uncover 7
callsub exponentialimpl_2
cover 4
store 8
store 7
store 6
store 5
load 8
load 5
callsub bytestoint_3
load 7
callsub widepower_1
b*
load 6
b/
b+
b exponentialimpl_2_l3
exponentialimpl_2_l2:
load 8
load 5
load 8
b*
b+
exponentialimpl_2_l3:
retsub

// bytes_to_int
bytestoint_3:
store 10
load 10
len
intc_2 // 8
<
bnz bytestoint_3_l2
load 10
load 10
len
intc_2 // 8
-
extract_uint64
b bytestoint_3_l3
bytestoint_3_l2:
load 10
btoi
bytestoint_3_l3:
retsub

// stack_to_wide
stacktowide_4:
store 9
itob
load 9
itob
concat
retsub

// create
create_5:
intc_0 // 1
return

// delete
delete_6:
intc_0 // 1
return

// update
update_7:
intc_0 // 1
return

// opt_in
optin_8:
retsub

// close_out
closeout_9:
intc_0 // 1
return

// unit_test
unittest_10:
store 3
itob
load 3
itob
callsub widefactorial_0
load 3
bytec_0 // 0x00000000000003e8
callsub exponentialimpl_2
bytec_0 // 0x00000000000003e8
b/
callsub bytestoint_3
retsub

// opup
opup_11:
intc_0 // 1
return