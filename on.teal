#pragma version 8
intcblock 1 0 8
bytecblock 0x00000000000003e8
txn NumAppArgs
intc_1 // 0
==
bnz main_l6
txna ApplicationArgs 0
pushbytes 0x9579aa48 // "unit_test(uint64,uint64)uint64"
==
bnz main_l5
txna ApplicationArgs 0
pushbytes 0x4c6bea72 // "opup()void"
==
bnz main_l4
err
main_l4:
txn OnCompletion
intc_1 // NoOp
==
txn ApplicationID
intc_1 // 0
!=
&&
assert
callsub opup_11
intc_0 // 1
return
main_l5:
txn OnCompletion
intc_1 // NoOp
==
txn ApplicationID
intc_1 // 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 0
txna ApplicationArgs 2
btoi
store 1
load 0
load 1
callsub unittest_10
store 2
pushbytes 0x151f7c75 // 0x151f7c75
load 2
itob
concat
log
intc_0 // 1
return
main_l6:
txn OnCompletion
intc_1 // NoOp
==
bnz main_l16
txn OnCompletion
intc_0 // OptIn
==
bnz main_l15
txn OnCompletion
pushint 2 // CloseOut
==
bnz main_l14
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz main_l13
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz main_l12
err
main_l12:
txn ApplicationID
intc_1 // 0
!=
assert
callsub delete_6
intc_0 // 1
return
main_l13:
txn ApplicationID
intc_1 // 0
!=
assert
callsub update_7
intc_0 // 1
return
main_l14:
txn ApplicationID
intc_1 // 0
!=
assert
callsub closeout_9
intc_0 // 1
return
main_l15:
txn ApplicationID
intc_1 // 0
!=
assert
callsub optin_8
intc_0 // 1
return
main_l16:
txn ApplicationID
intc_1 // 0
==
assert
callsub create_5
intc_0 // 1
return

// wide_factorial
widefactorial_0:
proto 1 1
frame_dig -1
bitlen
intc_0 // 1
==
bnz widefactorial_0_l2
frame_dig -1
frame_dig -1
intc_0 // 1
itob
b-
callsub widefactorial_0
b*
b widefactorial_0_l3
widefactorial_0_l2:
frame_dig -1
widefactorial_0_l3:
retsub

// wide_power
widepower_1:
proto 2 1
frame_dig -2
frame_dig -1
expw
callsub stacktowide_4
retsub

// exponential_impl
exponentialimpl_2:
proto 4 1
frame_dig -2
intc_0 // 1
==
bnz exponentialimpl_2_l2
frame_dig -4
frame_dig -3
frame_dig -2
itob
b/
frame_dig -2
intc_0 // 1
-
frame_dig -1
callsub exponentialimpl_2
frame_dig -1
frame_dig -4
callsub bytestoint_3
frame_dig -2
callsub widepower_1
b*
frame_dig -3
b/
b+
b exponentialimpl_2_l3
exponentialimpl_2_l2:
frame_dig -1
frame_dig -4
frame_dig -1
b*
b+
exponentialimpl_2_l3:
retsub

// bytes_to_int
bytestoint_3:
proto 1 1
frame_dig -1
len
intc_2 // 8
<
bnz bytestoint_3_l2
frame_dig -1
frame_dig -1
len
intc_2 // 8
-
extract_uint64
b bytestoint_3_l3
bytestoint_3_l2:
frame_dig -1
btoi
bytestoint_3_l3:
retsub

// stack_to_wide
stacktowide_4:
proto 0 1
store 3
itob
load 3
itob
concat
retsub

// create
create_5:
proto 0 0
intc_0 // 1
return

// delete
delete_6:
proto 0 0
intc_0 // 1
return

// update
update_7:
proto 0 0
intc_0 // 1
return

// opt_in
optin_8:
proto 0 0
retsub

// close_out
closeout_9:
proto 0 0
intc_0 // 1
return

// unit_test
unittest_10:
proto 2 1
intc_1 // 0
frame_dig -2
itob
frame_dig -1
itob
callsub widefactorial_0
frame_dig -1
bytec_0 // 0x00000000000003e8
callsub exponentialimpl_2
bytec_0 // 0x00000000000003e8
b/
callsub bytestoint_3
frame_bury 0
retsub

// opup
opup_11:
proto 0 0
intc_0 // 1
return