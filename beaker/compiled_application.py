import base64
import dataclasses
import json
from pathlib import Path
from typing import Any, Literal

from algosdk import abi, transaction
from algosdk.abi import Contract
from algosdk.transaction import StateSchema
from pyteal import TealType, Bytes, MethodConfig, CallConfig

from beaker.state import (
    ApplicationStateValue,
    AccountStateValue,
    StateDict,
)
from beaker.decorators import (
    MethodHints,
    DefaultArgument,
    DefaultArgumentType,
    DefaultArgumentClass,
)


@dataclasses.dataclass
class CompiledApplication:
    approval_program: str
    clear_program: str
    contract: Contract
    hints: dict[str, MethodHints]
    app_state: StateDict
    account_state: StateDict
    app_state_schema: StateSchema
    account_state_schema: StateSchema

    def to_json(self) -> str:
        return json.dumps(self.application_spec, indent=4)

    @property
    def application_spec(self) -> dict:
        return {
            "hints": {k: v.dictify() for k, v in self.hints.items() if not v.empty()},
            "source": {
                "approval": base64.b64encode(self.approval_program.encode()).decode(
                    "utf8"
                ),
                "clear": base64.b64encode(self.clear_program.encode()).decode("utf8"),
            },
            "state": {
                "global": {
                    "num_byte_slices": self.app_state_schema.num_byte_slices,
                    "num_uints": self.app_state_schema.num_uints,
                },
                "local": {
                    "num_byte_slices": self.account_state_schema.num_byte_slices,
                    "num_uints": self.account_state_schema.num_uints,
                },
            },
            "schema": {
                "global": self.app_state,
                "local": self.account_state,
            },
            "contract": self.contract.dictify(),
        }

    @staticmethod
    def from_json(application_spec: Path | str) -> "CompiledApplication":
        if isinstance(application_spec, Path):
            application_spec = application_spec.read_text()

        application_json = json.loads(application_spec)
        contract = abi.Contract.undictify(application_json["contract"])
        source = application_json["source"]
        approval_program = base64.b64decode(source["approval"]).decode("utf8")
        clear_program = base64.b64decode(source["clear"]).decode("utf8")
        hints_json = application_json["hints"]
        schema = application_json["schema"]
        state = application_json["state"]
        local_state = _state_schema_from_json(state["local"])
        global_state = _state_schema_from_json(state["global"])
        hints = dict(
            (x.name, _method_hints_from_json(hints_json.get(x.name)))
            for x in contract.methods
        )

        return CompiledApplication(
            approval_program=approval_program,
            clear_program=clear_program,
            app_state=schema["global"],
            account_state=schema["local"],
            app_state_schema=global_state,
            account_state_schema=local_state,
            contract=contract,
            hints=hints,
        )

    def dump(self, directory: Path) -> None:
        """write out the artifacts generated by the application to disk

        Args:
            directory: path to the directory where the artifacts should be written
        """
        directory.mkdir(exist_ok=True, parents=True)

        (directory / "approval.teal").write_text(self.approval_program)
        (directory / "clear.teal").write_text(self.clear_program)
        (directory / "contract.json").write_text(
            json.dumps(self.contract.dictify(), indent=4)
        )
        (directory / "application.json").write_text(self.to_json())


def _default_argument_from_json(default_argument: dict[str, Any]) -> DefaultArgument:
    source = default_argument["source"]
    data = default_argument["data"]

    def get_stack_type() -> Literal[TealType.bytes] | Literal[TealType.uint64]:
        stack_type = default_argument["stack_type"]
        if stack_type == "bytes":
            return TealType.bytes
        if stack_type == "uint64":
            return TealType.uint64
        raise NotImplementedError()

    resolver: DefaultArgumentType
    match source:
        case DefaultArgumentClass.Constant.value:
            resolver = data
        case DefaultArgumentClass.GlobalState.value:
            resolver = ApplicationStateValue(get_stack_type(), Bytes(data))
        case DefaultArgumentClass.LocalState.value:
            resolver = AccountStateValue(get_stack_type(), Bytes(data))
        case DefaultArgumentClass.ABIMethod.value:
            resolver = abi.Method.undictify(data)
        case _:
            raise NotImplementedError()
    return DefaultArgument(resolver)


def _method_hints_from_json(method_hints: dict[str, Any]) -> MethodHints:
    result = MethodHints()
    if method_hints is None:
        return result
    if "read_only" in method_hints:
        result.read_only = method_hints["read_only"]
    if "structs" in method_hints:
        # TODO: convert inner lists to tuple?,
        result.structs = method_hints["structs"]
    if "default_arguments" in method_hints:
        result.default_arguments = {
            k: _default_argument_from_json(v)
            for k, v in method_hints["default_arguments"].items()
        }
    if "config" in method_hints:
        result.config = MethodConfig(
            **{k: CallConfig[v] for k, v in method_hints["config"].items()}
        )
    return result


def _state_schema_from_json(schema: dict[str, Any]) -> transaction.StateSchema:
    return transaction.StateSchema(schema["num_uints"], schema["num_byte_slices"])
