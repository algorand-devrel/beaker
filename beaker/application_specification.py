import base64
import dataclasses
import json
from pathlib import Path
from typing import Any, TypedDict, TypeAlias, Literal

from algosdk import transaction
from algosdk.abi import Contract
from algosdk.abi.method import MethodDict
from algosdk.transaction import StateSchema
from pyteal import CallConfig, MethodConfig

__all__ = [
    "DefaultArgumentDict",
    "DefaultArgumentType",
    "MethodHints",
    "ApplicationSpecification",
    "AppSpecStateDict",
]

AppSpecStateDict: TypeAlias = dict[str, dict[str, dict]]


class StructArgDict(TypedDict):
    name: str
    elements: list[list[str]]


DefaultArgumentType: TypeAlias = Literal[
    "abi-method", "local-state", "global-state", "constant"
]


class DefaultArgumentDict(TypedDict):
    """
    DefaultArgument is a container for any arguments that may
    be resolved prior to calling some target method
    """

    source: DefaultArgumentType
    data: int | str | bytes | MethodDict


@dataclasses.dataclass
class MethodHints:
    """MethodHints provides hints to the caller about how to call the method"""

    #: hint to indicate this method can be called through Dryrun
    read_only: bool = False
    #: hint to provide names for tuple argument indices
    #: method_name=>param_name=>{name:str, elements:[str,str]}
    structs: dict[str, StructArgDict] = dataclasses.field(default_factory=dict)
    #: defaults
    default_arguments: dict[str, DefaultArgumentDict] = dataclasses.field(
        default_factory=dict
    )
    call_config: MethodConfig = dataclasses.field(default_factory=MethodConfig)

    def empty(self) -> bool:
        return not self.dictify()

    def dictify(self) -> dict[str, Any]:
        d: dict[str, Any] = {}
        if self.read_only:
            d["read_only"] = True
        if self.default_arguments:
            d["default_arguments"] = self.default_arguments
        if self.structs:
            d["structs"] = self.structs
        if not self.call_config.is_never():
            d["call_config"] = {
                k: v.name
                for k, v in self.call_config.__dict__.items()
                if v != CallConfig.NEVER
            }
        return d


@dataclasses.dataclass
class ApplicationSpecification:
    approval_program: str
    clear_program: str
    contract: Contract
    hints: dict[str, MethodHints]
    global_state: AppSpecStateDict
    local_state: AppSpecStateDict
    global_state_schema: StateSchema
    local_state_schema: StateSchema

    def dictify(self) -> dict:
        return {
            "hints": {k: v.dictify() for k, v in self.hints.items() if not v.empty()},
            "source": {
                "approval": base64.b64encode(self.approval_program.encode()).decode(
                    "utf8"
                ),
                "clear": base64.b64encode(self.clear_program.encode()).decode("utf8"),
            },
            "state": {
                "global": {
                    "num_byte_slices": self.global_state_schema.num_byte_slices,
                    "num_uints": self.global_state_schema.num_uints,
                },
                "local": {
                    "num_byte_slices": self.local_state_schema.num_byte_slices,
                    "num_uints": self.local_state_schema.num_uints,
                },
            },
            "schema": {
                "global": self.global_state,
                "local": self.local_state,
            },
            "contract": self.contract.dictify(),
        }

    def to_json(self) -> str:
        return json.dumps(self.dictify(), indent=4)

    @staticmethod
    def from_json(application_spec: Path | str) -> "ApplicationSpecification":
        if isinstance(application_spec, Path):
            application_spec = application_spec.read_text()

        application_json = json.loads(application_spec)
        contract = Contract.undictify(application_json["contract"])
        source = application_json["source"]
        approval_program = base64.b64decode(source["approval"]).decode("utf8")
        clear_program = base64.b64decode(source["clear"]).decode("utf8")
        schema = application_json["schema"]
        state = application_json["state"]
        local_state = transaction.StateSchema(**state["local"])
        global_state = transaction.StateSchema(**state["global"])

        hints = {
            k: _method_hints_from_json(v) for k, v in application_json["hints"].items()
        }

        return ApplicationSpecification(
            approval_program=approval_program,
            clear_program=clear_program,
            global_state=schema["global"],
            local_state=schema["local"],
            global_state_schema=global_state,
            local_state_schema=local_state,
            contract=contract,
            hints=hints,
        )

    def export(self, directory: Path | str | None = None) -> None:
        """write out the artifacts generated by the application to disk

        Args:
            directory(optional): path to the directory where the artifacts should be written
        """
        if directory is None:
            output_dir = Path.cwd()
        else:
            output_dir = Path(directory)
            output_dir.mkdir(exist_ok=True, parents=True)

        (output_dir / "approval.teal").write_text(self.approval_program)
        (output_dir / "clear.teal").write_text(self.clear_program)
        (output_dir / "contract.json").write_text(
            json.dumps(self.contract.dictify(), indent=4)
        )
        (output_dir / "application.json").write_text(self.to_json())


def _method_hints_from_json(method_hints: dict[str, Any]) -> MethodHints:
    method_hints["call_config"] = MethodConfig(
        **{k: CallConfig[v] for k, v in method_hints.get("call_config", {}).items()}
    )
    return MethodHints(**method_hints)
